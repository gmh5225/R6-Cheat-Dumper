#include "exploits.hpp"
#include "../../globals.hpp"

uint8_t shellcode[]
{
	0x53, 0x48, 0x83, 0xec, 0x20, 0x48, 0xb8, 0xfe, 0xca, 0xef, 0xbe, 0xfe,
	0xca, 0xad, 0xde, 0xff, 0xd0, 0x48, 0x8d, 0x54, 0x24, 0x28, 0x48, 0x89,
	0xc3, 0x48, 0x8b, 0x42, 0x30, 0x48, 0x89, 0xc1, 0x48, 0xb8, 0xfe, 0xca,
	0xef, 0xbe, 0xfe, 0xca, 0xad, 0xde, 0x48, 0x29, 0xc1, 0x48, 0x81, 0xf9,
	0x41, 0x52, 0xe0, 0x00, 0x75, 0x1a, 0x48, 0x8b, 0x42, 0x30, 0x48, 0x8d,
	0x48, 0x68, 0x48, 0x89, 0x4a, 0x30, 0x48, 0x89, 0xf8, 0xc6, 0x40, 0x52,
	0x00, 0x48, 0x89, 0xf8, 0xc6, 0x40, 0x51, 0x00, 0x48, 0x89, 0xd8, 0x48,
	0x83, 0xc4, 0x20, 0x5b, 0xc3
};

bool exploits::unlock_all(bool enable) {
	/*const auto image_allocation = protect_virtual_memory(sizeof(shellcode), PAGE_EXECUTE_READWRITE); // fix with driver func
	const auto function_address = offsets::module_base + 0x5AC1270;

	*reinterpret_cast<uint64_t*>(&shellcode[0x7]) = read_memory<uint64_t>(function_address);
	*reinterpret_cast<uint64_t*>(&shellcode[0x22]) = offsets::module_base;

	write_memory(image_allocation, shellcode, sizeof(shellcode));
	write_memory(function_address, shellcode, sizeof(shellcode));
	write_memory(image_allocation + 0x4f, enable ? 0 : 1);
	return enable;*/

	return true;
}